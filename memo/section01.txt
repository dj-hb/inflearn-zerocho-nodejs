1. 호출 스택 알아보기

  * 호출 스택 - 실행 컨텍스트와 밀접한 연관이 있음

  * "함수를 선언했다" - 함수를 '메모리'에 올렸다
    - 메모리 : 임시 저장장치

  * 함수 호출 시, 호출 순서대로 쌓이고 역순으로 실행됨 (실행 완료 시 스택에서 빠짐)

  * 호출 스택 맨 밑에는 anonymous 함수가 있음 (가상의 전역 컨텍스트)
    - anonymous 가 스택에서 빠지면 파일의 모든 함수 실행 완료인 셈

  * 호출 스택 만으로는 자바스크립트 동작이 설명되지 않는다. --> 이벤트 루프


2. 이벤트루프 알아보기

  * 호출스택 --> 백그라운드 --> 태스크큐 --> 호출스택
  
  * 동작 순서
    - setTimeout 같은 비동기 함수는 백그라운드로 작업(타이머)을 보낸다.
      (백그라운드의 작업은 다른 스레드가 실행)
    - anonymous 를 끝으로 호출스택이 비워진다.
    - 백그라운드에서 완료된 작업(타이머)은 태스크큐로 넘어간다.
    - '호출스택이 비어있을 때' 이벤트루프가 태스크큐의 함수를 호출스택으로 보낸다.
    - 태스크큐에서 호출스택으로 넘어온 함수가 실행된다.
  
  * 백그라운드로 보낼 수 있는 함수들은 제한되어 있다.
    - setTimeout, setInterval 등
    - 네트워크 요청
    - 하드디스크 파일 읽는 명령어
    - 암호화 명령어
    - 압축 명령어

    - 이외의 코드들은 호출스택 안에서 동기적으로 작동

  * Promise의 then은 비동기로 작동 (백그라운드, 태스크큐로 넘어간다)
    - 그러나, 태스크큐로 넘어간 다른 작업들과 함께 순차적으로 실행되지 않고
      우선적으로 then 내부의 코드가 먼저 실행됨 (새치기?!)
    - 새치기하는 애들
      - Promise 의 then, catch
      - process.nextTick

  * 자바스크립트는 싱글스레드인데 어떻게 백그라운드에서 동시에 실행?
    - 백그라운드는 C++ 내지는 V8 엔진이 알아서 해준다. 백그라운드는 자바스크립트로 돌아가지 않음


3. var, const, let

  * 






4. 템플릿 문자열, 객체 리터럴
5. 화살표 함수
6. 비구조화 할당
7. 클래스
8. Promise, async/await
9. 프런트엔드 자바스크립트
