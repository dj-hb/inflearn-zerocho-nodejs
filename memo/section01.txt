1. 호출 스택 알아보기

  * 호출 스택 - 실행 컨텍스트와 밀접한 연관이 있음

  * "함수를 선언했다" - 함수를 '메모리'에 올렸다
    - 메모리 : 임시 저장장치

  * 함수 호출 시, 호출 순서대로 쌓이고 역순으로 실행됨 (실행 완료 시 스택에서 빠짐)

  * 호출 스택 맨 밑에는 anonymous 함수가 있음 (가상의 전역 컨텍스트)
    - anonymous 가 스택에서 빠지면 파일의 모든 함수 실행 완료인 셈

  * 호출 스택 만으로는 자바스크립트 동작이 설명되지 않는다. --> 이벤트 루프



2. 이벤트루프 알아보기

  * 호출스택 --> 백그라운드 --> 태스크큐 --> 호출스택
  
  * 동작 순서
    - setTimeout 같은 비동기 함수는 백그라운드로 작업(타이머)을 보낸다.
      (백그라운드의 작업은 다른 스레드가 실행)
    - anonymous 를 끝으로 호출스택이 비워진다.
    - 백그라운드에서 완료된 작업(타이머)은 태스크큐로 넘어간다.
    - '호출스택이 비어있을 때' 이벤트루프가 태스크큐의 함수를 호출스택으로 보낸다.
    - 태스크큐에서 호출스택으로 넘어온 함수가 실행된다.
  
  * 백그라운드로 보낼 수 있는 함수들은 제한되어 있다.
    - setTimeout, setInterval 등
    - 네트워크 요청
    - 하드디스크 파일 읽는 명령어
    - 암호화 명령어
    - 압축 명령어

    - 이외의 코드들은 호출스택 안에서 동기적으로 작동

  * Promise의 then은 비동기로 작동 (백그라운드, 태스크큐로 넘어간다)
    - 그러나, 태스크큐로 넘어간 다른 작업들과 함께 순차적으로 실행되지 않고
      우선적으로 then 내부의 코드가 먼저 실행됨 (새치기?!)
    - 새치기하는 애들
      - Promise 의 then, catch
      - process.nextTick

  * 자바스크립트는 싱글스레드인데 어떻게 백그라운드에서 동시에 실행?
    - 백그라운드는 C++ 내지는 V8 엔진이 알아서 해준다. 백그라운드는 자바스크립트로 돌아가지 않음



3. var, const, let

  * 레거시 코드 분석 시 var 특성 알아야 함
    - var : 블록 스코프를 무시한다.
    - var 가 스코프 내부에서만 사용되려면?
      함수 스코프는 존중한다 (function () { 여기 })
      
  * const, let
    - const : 블록 스코프 존중



4. 템플릿 문자열, 객체 리터럴

  * 템플릿 문자열 (또는 백틱 문자열) : `${}`



5. 화살표 함수

  * let 과 const 는 var 를 대체할 수 있다
    하지만 화살표 함수는 function 을 완벽히 대체할 수 없다.

  * 중괄호 뒤에 바로 return 나오면 중괄호 생략 가능
    - 가독성을 위해 리턴값을 괄호로 묶어주는 게 좋을 수 있다.
    - 반환값이 객체라면 리턴값을 괄호로 꼭 묶어줘야 한다.
      (중괄호가 객체를 의미하는지 함수의 바디를 의미하는지 알 수 없기 때문)

  * 매개변수가 하나일 경우 (매개변수가 들어있는) 괄호 생략 가능

  * 화살표 함수가 function 을 완벽히 대체할 수 없는 이유 --> this 때문
    - function 에서는 this 를 따로 갖는다.
    - 화살표 함수는 부모의 this 를 물려받는다.



6. 구조분해 할당

  * 번역이 바뀌었음
    비구조화 할당 --> 구조분해 할당
    
  * 객체 안에 this 가 사용된 경우에는 구조분해 할당을 사용하지 않는 게 좋다.



7. 클래스

  * 생성자? prototype? instanceof?



8. Promise, async/await

  * Promise : 내용이 실행은 되었지만 아직 결과를 반환하지 않은 객체
    - 결과를 들고 있다가 추후에 (then) 꺼내서 쓸 수 있다...!
    - '변수에 저장해놓고' 다른 코드 실행 후, 필요한 시점에 가서 then 이나 catch 붙여서 사용하는 방식

  * 여러 프로미스 객체들 한 번에 처리할 수도 있음
    - Promise.all
    - Promise.allSettled

  * await 을 쓰면 변수에 resolve 결과값을 바로 저장할 수 있다.
    - 여러 개의 then 이 붙어있는 코드도 한 번 더 축약 가능
  
  * top-level await 을 쓰면 async 함수 내부가 아니더라도 await 사용 가능

  * async 함수는 기본적으로 Promise 를 간단하게 쓰는 방법이다.
    - async 함수의 return 값 또한 Promise 와 마찬가지로 then 을 통해서 받거나 await 을 써야 한다.

  * catch 가 없는데, async/await 을 사용한 로직이 실패하는 경우는 어떻게? (resolve 만 처리 가능하고 reject 는 처리할 수가 없는데?)
    - try/catch 사용

  * for await
    - 프로미스 배열에 대한 반복문
    - resolve 된 값들이 변수에 담겨져서 나온다



9. 프런트엔드 자바스크립트

  * 
